package ru.progwards.java2.lessons.gc;

import java.util.List;

/*
Имеется массив байт, который будет представлять из себя кучу - heap.
Нужно будет написать алгоритм, который выделяет и освобождает память
(ячейки в массиве) и делает дефрагментацию.

Для реализации этих методов надо будет завести структуру данных - список
(или другая структура данных) свободных блоков. При выделении памяти искать
блок подходящего размера в этом списке, при освобождении - добавлять его туда.
Для проверки валидности освобождения указателей - список (или другая структура данных)
занятых блоков. При компактизации саму процедуру замены старый указателей на новые
опускаем, поэтому и делаем не очень эффективное копирование самих данных, что бы была
близкая производительность.
*/
public class Heap {

    public byte[] bytes;          // куча
    public final int maxHeapSize; // максимальный размер кучи
    private int emptyPos;         // указатель на свободное пространство
    private IntDictionary<List<Integer>> freeZones; // индекс - размер свободной зоны, значение - список позиций начала
    private IntDictionary<Integer> oSizeInPos; // индекс - позиция, значение - размер объекта

    Heap(){
        this.maxHeapSize = 64;
        init();
    }

    Heap(int maxHeapSize){
        this.maxHeapSize = maxHeapSize;
        init();
    }

    private void init() {
        bytes = new byte[maxHeapSize];
        emptyPos = 0;
        freeZones = new IntHashTableChained<List<Integer>>();
        oSizeInPos = new IntHashTableChained<Integer>();
    }

    // "размещает", т.е. помечает как занятый блок памяти с количеством ячеек массива heap равным size.
    // Соответственно это должен быть непрерывный блок (последовательность ячеек), которые на момент
    // выделения свободны. Возвращает "указатель" - индекс первой ячейки в массиве, размещенного блока.
    public int malloc(int size) {
        return emptyPos;
    }

    // "удаляет", т.е. помечает как свободный блок памяти по "указателю". Проверять валидность указателя - т.е.
    // то, что он соответствует началу ранее выделенного блока, а не его середине, или вообще, уже свободному.
    public void free(int size) {

    }

    // осуществляет дефрагментацию кучи - ищет смежные свободные блоки, границы которых
    // соприкасаются и которые можно слить в один.
    public void defrag() {

    }

    // компактизация кучи - перенос всех занятых блоков в начало хипа, с копированием самих данных - элементов
    // массива. Для более точной имитации производительности копировать просто в цикле по одному элементу, не
    // используя System.arraycopy. Обязательно запускаем compact из malloc если не нашли блок подходящего размера
    public void compact() {

    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder(bytes.length);
        for (byte b:bytes) {
            sb.append(b);
        }
        return "Heap{" +
                "bytes=" + sb.toString() +
                ", maxHeapSize=" + maxHeapSize +
                '}';
    }
}
